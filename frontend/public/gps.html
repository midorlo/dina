<!doctype html>
<html lang="de">
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>Location Selector – Demo (HTML + JS, CDN, no CLI)</title>
    <!-- Minimal CSS via CDN (optional) -->
    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@2.0.6/css/pico.min.css">
    <style>
        :root {
            --gap: .5rem;
            --ring: 2px solid #4c9ffe;
        }

        body {
            padding: 1rem;
        }

        location-selector {
            display: block;
        }

        /* Shadow DOM content styles live inside component, but a few globals help */
    </style>
</head>
<body>
<main class="container">
    <h1>Location Selector – Demo</h1>

    <!-- Config: set via server/template. Keep tokens out of repo. -->
    <script>
        window.LOCATION_WIDGET_CONFIG = {
            provider: {
                name: 'mapbox',
                mapboxToken: 'YOUR_MAPBOX_ACCESS_TOKEN', // TODO: replace
                language: (navigator.language || 'de').slice(0, 2),
            },
            i18n: {
                de: {
                    countryLabel: 'Land',
                    cityLabel: 'Stadt / PLZ',
                    radiusLabel: 'Umkreis',
                    km: 'km',
                    gps: 'Standort ermitteln',
                    gpsDisabled: 'Nur über HTTPS oder ohne Geolocation verfügbar',
                    noResults: 'Keine Treffer',
                    recent: 'Zuletzt verwendet',
                    tryAgain: 'Erneut versuchen',
                    denied: 'Zugriff auf Standort verweigert',
                    timeout: 'Standortbestimmung zeitüberschritten',
                    unavailable: 'Standort nicht verfügbar',
                    resultsCount: (n) => `${n} Treffer`,
                    offline: 'Offline: Autocomplete deaktiviert. Manuelle Eingabe möglich.',
                },
                en: {
                    countryLabel: 'Country',
                    cityLabel: 'City / ZIP',
                    radiusLabel: 'Radius',
                    km: 'km',
                    gps: 'Use my location',
                    gpsDisabled: 'Requires HTTPS or Geolocation not available',
                    noResults: 'No results',
                    recent: 'Recently used',
                    tryAgain: 'Try again',
                    denied: 'Location permission denied',
                    timeout: 'Location request timed out',
                    unavailable: 'Location unavailable',
                    resultsCount: (n) => `${n} results`,
                    offline: 'Offline: Autocomplete disabled. Manual input allowed.',
                }
            },
            // Optional server-side GeoIP country code (e.g., 'DE')
            GEOIP_COUNTRY_CODE: window.GEOIP_COUNTRY_CODE || null,
            cacheTTLMinutes: 30,
            radius: {min: 1, max: 100, step: 1, default: 25},
            countriesSource: 'https://unpkg.com/world-countries/countries.json',
        };
    </script>

    <!-- The Component Instance -->
    <location-selector></location-selector>

    <article>
        <header><strong>Debug Events</strong></header>
        <pre id="debug"></pre>
    </article>
</main>

<script type="module">
    /*****************
     * Utilities
     *****************/
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    const normalizeText = (s) => (s || '')
        .normalize('NFD')
        .replace(/\p{Diacritic}/gu, '')
        .replace(/ß/g, 'ss'); // basic diacritic tolerance

    // localStorage with TTL
    const TTLStore = {
        _key: 'location_widget_recent_v1',
        _now: () => Date.now(),
        _ttlMs: () => (window.LOCATION_WIDGET_CONFIG?.cacheTTLMinutes ?? 30) * 60_000,
        getAll() {
            try {
                const raw = JSON.parse(localStorage.getItem(this._key) || '[]');
                const now = this._now();
                return raw.filter(x => (now - (x.ts || 0)) < this._ttlMs());
            } catch {
                return [];
            }
        },
        add(entry) {
            const arr = this.getAll().filter(e => e.placeId !== entry.placeId);
            arr.unshift({...entry, ts: this._now()});
            localStorage.setItem(this._key, JSON.stringify(arr.slice(0, 10)));
        }
    };

    /*****************
     * Provider Interface + Mapbox
     *****************/
    class GeocoderProvider {
        /** @param {AbortSignal} signal */
        async search(q, countryCode, signal) {
            throw new Error('not implemented');
        }

        /** @param {AbortSignal} signal */
        async reverse(lat, lon, signal) {
            throw new Error('not implemented');
        }

        /** Normalize provider features → common model */
        normalizeFeature(f) {
            throw new Error('not implemented');
        }
    }

    class MapboxProvider extends GeocoderProvider {
        constructor(token, language = 'en') {
            super();
            this.token = token;
            this.language = language;
            if (!token) console.warn('[LocationSelector] Mapbox token missing');
        }

        async search(q, countryCode, signal) {
            const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${encodeURIComponent(q)}.json`);
            url.searchParams.set('access_token', this.token);
            url.searchParams.set('autocomplete', 'true');
            url.searchParams.set('types', 'place,locality,postcode');
            url.searchParams.set('language', this.language);
            url.searchParams.set('limit', '10');
            if (countryCode) url.searchParams.set('country', countryCode.toLowerCase());
            const res = await fetch(url, {signal});
            if (!res.ok) throw new Error(`Mapbox ${res.status}`);
            const data = await res.json();
            return data.features.map(f => this.normalizeFeature(f));
        }

        async reverse(lat, lon, signal) {
            const url = new URL(`https://api.mapbox.com/geocoding/v5/mapbox.places/${lon},${lat}.json`);
            url.searchParams.set('access_token', this.token);
            url.searchParams.set('types', 'place,locality,postcode');
            url.searchParams.set('language', this.language);
            url.searchParams.set('limit', '1');
            const res = await fetch(url, {signal});
            if (!res.ok) throw new Error(`Mapbox ${res.status}`);
            const data = await res.json();
            const f = data.features?.[0];
            return f ? this.normalizeFeature(f) : null;
        }

        normalizeFeature(f) {
            const [lon, lat] = f.center || [null, null];
            const ctx = f.context || [];
            const country = ctx.find(c => c.id?.startsWith('country'))?.short_code?.toUpperCase() || f.properties?.short_code?.toUpperCase() || null;
            const region = ctx.find(c => c.id?.startsWith('region'))?.short_code?.toUpperCase() || null;
            const place = f.text || f.place_name || '';
            const label = `${f.place_name}`;
            const bbox = f.bbox ? [f.bbox[0], f.bbox[1], f.bbox[2], f.bbox[3]] : undefined;
            return {
                label,
                lat, lon,
                placeId: f.id,
                adminPath: [country, region, place].filter(Boolean),
                country: country || undefined,
                bbox,
                _raw: f,
            };
        }
    }

    /*****************
     * Country data loader (via CDN) + Intl names
     *****************/
    async function loadCountries() {
        const cfg = window.LOCATION_WIDGET_CONFIG;
        try {
            const res = await fetch(cfg.countriesSource);
            const list = await res.json();
            // Normalize to {code, name}
            const lang = (cfg.provider?.language || (navigator.language || 'en')).slice(0, 2);
            const dn = new Intl.DisplayNames([lang], {type: 'region'});
            return list.map(c => ({
                code: c.cca2,
                name: dn.of(c.cca2) || c.name.common
            })).sort((a, b) => a.name.localeCompare(b.name));
        } catch (e) {
            console.warn('[LocationSelector] country source failed, using fallback', e);
            return [
                {code: 'DE', name: 'Deutschland'}, {code: 'AT', name: 'Österreich'}, {code: 'CH', name: 'Schweiz'},
                {code: 'NL', name: 'Niederlande'}, {code: 'PL', name: 'Polen'}, {code: 'FR', name: 'Frankreich'},
                {code: 'IT', name: 'Italien'}, {code: 'ES', name: 'Spanien'}, {
                    code: 'US',
                    name: 'United States'
                }, {code: 'GB', name: 'United Kingdom'},
            ];
        }
    }

    /*****************
     * Web Component
     *****************/
    class LocationSelector extends HTMLElement {
        constructor() {
            super();
            this.attachShadow({mode: 'open'});
        }

        connectedCallback() {
            this.render();
        }

        get cfg() {
            return window.LOCATION_WIDGET_CONFIG || {};
        }

        get i18n() {
            const lang = (this.cfg.provider?.language || (navigator.language || 'en')).slice(0, 2);
            return this.cfg.i18n?.[lang] || this.cfg.i18n?.en;
        }

        async render() {
            const i18n = this.i18n;
            this.shadowRoot.innerHTML = `
          <style>
            :host { display:block; }
            .grid { display:grid; grid-template-columns: 1fr 1fr auto; gap: var(--gap); align-items: end; }
            .row { display:flex; gap: var(--gap); align-items: center; }
            label { font-weight: 600; }
            input[type=range] { width: 200px; }
            button[disabled] { cursor: not-allowed; }
            .combobox { position: relative; }
            .listbox { position: absolute; z-index: 20; left:0; right:0; top: calc(100% + 2px); max-height: 260px; overflow:auto; border: 1px solid #ddd; border-radius: .5rem; background: var(--pico-background-color); box-shadow: 0 6px 24px rgba(0,0,0,.08); }
            .option { padding: .5rem .75rem; cursor: pointer; }
            .option[aria-selected="true"], .option:hover { background: rgba(0,0,0,.06); }
            .section { padding: .25rem .75rem; font-size: .85rem; color: var(--pico-muted-color); border-top: 1px solid #eee; }
            .sr-only { position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }
            .status { margin-top:.25rem; min-height:1.2em; }
            .banner { margin-top:.5rem; padding:.5rem .75rem; border-radius:.5rem; background: #fff3cd; border:1px solid #ffe69c; color:#7a5b00; }
          </style>
          <div class="grid">
            <div class="combobox">
              <label for="countryInput">${i18n.countryLabel}</label>
              <input id="countryInput" type="text" autocomplete="off" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-controls="countryList" aria-haspopup="listbox" placeholder="DE / Deutschland" />
              <div id="countryList" class="listbox" role="listbox" hidden></div>
              <p id="countryStatus" class="status sr-only" aria-live="polite"></p>
            </div>
            <div class="combobox">
              <label for="cityInput">${i18n.cityLabel}</label>
              <input id="cityInput" type="text" autocomplete="off" role="combobox" aria-autocomplete="list" aria-expanded="false" aria-controls="cityList" aria-haspopup="listbox" placeholder="Berlin / 10115" />
              <div id="cityList" class="listbox" role="listbox" hidden></div>
              <p id="cityStatus" class="status sr-only" aria-live="polite"></p>
            </div>
            <div class="row">
              <button id="gpsBtn" type="button">${i18n.gps}</button>
            </div>
            <div class="row" style="grid-column: 1 / span 3;">
              <label for="radiusRange" style="margin-right:.5rem;">${i18n.radiusLabel}</label>
              <input id="radiusRange" type="range" min="${this.cfg.radius?.min ?? 1}" max="${this.cfg.radius?.max ?? 100}" step="${this.cfg.radius?.step ?? 1}" value="${this.cfg.radius?.default ?? 25}" />
              <output id="radiusOut" for="radiusRange" style="margin-left:.5rem;"></output><span style="margin-left:.25rem;">${i18n.km}</span>
            </div>
            <div id="banner" class="banner" style="grid-column: 1 / span 3; display:none;"></div>
          </div>
        `;

            this.state = {
                country: null,
                place: null,
                radiusKm: this.cfg.radius?.default ?? 25,
                source: 'manual',
            };

            // Offline handling
            const banner = this.$('#banner');
            const setOfflineBanner = () => {
                if (!navigator.onLine) {
                    banner.textContent = this.i18n.offline;
                    banner.style.display = 'block';
                    this.disableAutocomplete(true);
                } else {
                    banner.style.display = 'none';
                    this.disableAutocomplete(false);
                }
            };
            window.addEventListener('online', setOfflineBanner);
            window.addEventListener('offline', setOfflineBanner);
            setOfflineBanner();

            // Provider
            const pCfg = this.cfg.provider || {};
            this.provider = new MapboxProvider(pCfg.mapboxToken, pCfg.language || 'en');

            // Countries
            this.countries = await loadCountries();
            this.initCountryCombobox();
            this.initCityCombobox();
            this.initRadius();
            this.initGPS();

            // Default country (GeoIP code if provided)
            const defaultCode = this.cfg.GEOIP_COUNTRY_CODE || (this.countries.find(c => c.code === 'DE') && 'DE');
            if (defaultCode) this.setCountryByCode(defaultCode);

            // Expose current value getter
            this.value = () => ({...this.state});
        }

        // Shorthand
        $(sel) {
            return this.shadowRoot.querySelector(sel);
        }

        disableAutocomplete(disabled) {
            this.$('#cityInput').disabled = !!disabled;
        }

        /*********** Country Combobox ***********/
        initCountryCombobox() {
            const input = this.$('#countryInput');
            const list = this.$('#countryList');
            const status = this.$('#countryStatus');
            let lastQuery = '', idx = -1;
            let options = [];

            const render = (items) => {
                list.innerHTML = '';
                if (!items.length) {
                    const div = document.createElement('div');
                    div.className = 'option';
                    div.setAttribute('role', 'option');
                    div.textContent = this.i18n.noResults;
                    div.dataset.empty = '1';
                    list.appendChild(div);
                } else {
                    for (const it of items) {
                        const opt = document.createElement('div');
                        opt.className = 'option';
                        opt.setAttribute('role', 'option');
                        opt.dataset.code = it.code;
                        opt.textContent = `${it.name} (${it.code})`;
                        list.appendChild(opt);
                    }
                }
                list.hidden = false;
                input.setAttribute('aria-expanded', 'true');
                status.textContent = this.i18n.resultsCount(items.length);
                idx = -1;
                setActive(idx);
            };
            const setActive = (i) => {
                [...list.children].forEach((el, j) => el.setAttribute('aria-selected', String(i === j)));
            };

            const filter = (q) => {
                const n = normalizeText(q).toLowerCase();
                return this.countries.filter(c => normalizeText(`${c.name} ${c.code}`).toLowerCase().includes(n)).slice(0, 20);
            };

            input.addEventListener('input', () => {
                const q = input.value.trim();
                lastQuery = q;
                const items = q ? filter(q) : this.countries.slice(0, 20);
                options = items;
                render(items);
            });
            input.addEventListener('focus', () => {
                const q = input.value.trim();
                options = q ? filter(q) : this.countries.slice(0, 20);
                render(options);
            });
            input.addEventListener('blur', () => setTimeout(() => {
                list.hidden = true;
                input.setAttribute('aria-expanded', 'false');
            }, 120));

            input.addEventListener('keydown', (e) => {
                if (list.hidden) return;
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    idx = Math.min(idx + 1, list.children.length - 1);
                    setActive(idx);
                }
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    idx = Math.max(idx - 1, 0);
                    setActive(idx);
                }
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const el = list.children[idx] || list.children[0];
                    if (el && !el.dataset.empty) select(el.dataset.code);
                }
                if (e.key === 'Escape') {
                    list.hidden = true;
                    input.setAttribute('aria-expanded', 'false');
                }
            });
            list.addEventListener('mousedown', (e) => {
                const el = e.target.closest('.option');
                if (el && !el.dataset.empty) select(el.dataset.code);
            });

            const select = (code) => {
                const c = this.countries.find(x => x.code === code);
                if (!c) return;
                input.value = `${c.name} (${c.code})`;
                list.hidden = true;
                input.setAttribute('aria-expanded', 'false');
                this.state.country = {code: c.code, name: c.name};
                this.dispatch('location:country-change', {country: this.state.country});
                // Reset city / place
                this.resetPlace();
            };

            this.setCountryByCode = (code) => {
                const c = this.countries.find(x => x.code === code);
                if (c) select(c.code);
            };
        }

        resetPlace() {
            const cityInput = this.$('#cityInput');
            cityInput.value = '';
            this.state.place = null;
            this.dispatch('location:reset-place', {});
        }

        /*********** City Combobox (with provider) ***********/
        initCityCombobox() {
            const input = this.$('#cityInput');
            const list = this.$('#cityList');
            const status = this.$('#cityStatus');
            const recentHeader = () => {
                const s = document.createElement('div');
                s.className = 'section';
                s.textContent = this.i18n.recent;
                return s;
            };
            let idx = -1;
            let canceler = null;
            let lastController = null;
            let currentItems = [];

            const minChars = 2;
            const debounceMs = 350;
            const debounced = (fn, ms) => {
                let t;
                return (...a) => {
                    clearTimeout(t);
                    t = setTimeout(() => fn(...a), ms);
                };
            };

            const setActive = (i) => {
                [...list.querySelectorAll('.option')].forEach((el, j) => el.setAttribute('aria-selected', String(i === j)));
            };

            const renderItems = (items, {includeRecents = true} = {}) => {
                list.innerHTML = '';
                const recents = includeRecents ? TTLStore.getAll() : [];
                if (includeRecents && recents.length) {
                    list.appendChild(recentHeader());
                    recents.forEach(addItemFromRecent);
                }
                if (!items.length) {
                    const di = document.createElement('div');
                    di.className = 'option';
                    di.setAttribute('role', 'option');
                    di.dataset.empty = '1';
                    di.textContent = this.i18n.noResults;
                    list.appendChild(di);
                } else {
                    items.forEach(addItemFromProvider);
                }
                list.hidden = false;
                input.setAttribute('aria-expanded', 'true');
                status.textContent = this.i18n.resultsCount(items.length);
                idx = -1;
                setActive(idx);
            };

            const addItemFromProvider = (it) => {
                const div = document.createElement('div');
                div.className = 'option';
                div.setAttribute('role', 'option');
                // Safe textContent to avoid XSS
                div.textContent = `${it.label}`;
                div.dataset.type = 'provider';
                div.dataset.payload = JSON.stringify(it);
                list.appendChild(div);
            };
            const addItemFromRecent = (r) => {
                const div = document.createElement('div');
                div.className = 'option';
                div.setAttribute('role', 'option');
                div.textContent = `${r.label}`;
                div.dataset.type = 'recent';
                div.dataset.payload = JSON.stringify(r);
                list.appendChild(div);
            };

            const doSearch = async (q) => {
                if (lastController) lastController.abort();
                lastController = new AbortController();
                try {
                    const res = await this.provider.search(q, this.state.country?.code, lastController.signal);
                    currentItems = res;
                    renderItems(res);
                } catch (e) {
                    if (e.name === 'AbortError') return;
                    this.error(e);
                    currentItems = [];
                    renderItems([]);
                }
            };

            const onInput = debounced(async () => {
                const q = input.value.trim();
                this.dispatch('location:city-input', {query: q});
                if (!q || q.length < minChars) {
                    renderItems([], {includeRecents: true});
                    return;
                }
                await doSearch(q);
            }, debounceMs);

            input.addEventListener('input', onInput);
            input.addEventListener('focus', () => {
                renderItems([], {includeRecents: true});
            });
            input.addEventListener('blur', () => setTimeout(() => {
                list.hidden = true;
                input.setAttribute('aria-expanded', 'false');
            }, 120));

            const selectPayload = (payload) => {
                const p = JSON.parse(payload);
                // If recent entry picked, keep structure similar to provider
                const place = p.lat ? p : {...p};
                this.state.place = {
                    label: place.label,
                    lat: place.lat,
                    lon: place.lon,
                    placeId: place.placeId,
                    adminPath: place.adminPath,
                    bbox: place.bbox,
                };
                this.state.source = (p.source === 'gps') ? 'gps' : (p.source === 'recent' ? 'recent' : 'autocomplete');
                input.value = place.label;
                list.hidden = true;
                input.setAttribute('aria-expanded', 'false');
                // Cache recent (flag gps separately by source)
                TTLStore.add({
                    label: place.label,
                    lat: place.lat, lon: place.lon,
                    placeId: place.placeId,
                    adminPath: place.adminPath,
                    country: this.state.country?.code,
                    source: this.state.source,
                });
                this.emitSelection();
                this.dispatch('location:city-selected', {place: this.state.place});
            };

            list.addEventListener('mousedown', (e) => {
                const el = e.target.closest('.option');
                if (!el || el.dataset.empty) return;
                selectPayload(el.dataset.payload);
            });

            input.addEventListener('keydown', (e) => {
                if (list.hidden) return;
                const options = [...list.querySelectorAll('.option')].filter(el => !el.dataset.empty);
                if (e.key === 'ArrowDown') {
                    e.preventDefault();
                    idx = Math.min(idx + 1, options.length - 1);
                    setActive(idx);
                }
                if (e.key === 'ArrowUp') {
                    e.preventDefault();
                    idx = Math.max(idx - 1, 0);
                    setActive(idx);
                }
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const el = options[idx] || options[0];
                    if (el) selectPayload(el.dataset.payload);
                }
                if (e.key === 'Escape') {
                    list.hidden = true;
                    input.setAttribute('aria-expanded', 'false');
                }
            });
        }

        /*********** GPS ***********/
        initGPS() {
            const btn = this.$('#gpsBtn');
            const secure = location.protocol === 'https:' || location.hostname === 'localhost';
            if (!('geolocation' in navigator) || !secure) {
                btn.disabled = true;
                btn.title = this.i18n.gpsDisabled;
                return;
            }
            btn.addEventListener('click', async () => {
                this.dispatch('location:use-gps', {});
                try {
                    const pos = await new Promise((resolve, reject) => navigator.geolocation.getCurrentPosition(resolve, reject, {
                        enableHighAccuracy: true,
                        timeout: 10000,
                        maximumAge: 0
                    }));
                    const {latitude: lat, longitude: lon} = pos.coords;
                    const controller = new AbortController();
                    const feature = await this.provider.reverse(lat, lon, controller.signal);
                    if (!feature) throw new Error('Reverse geocoding returned no result');
                    // If country not set, set it from reverse result
                    if (!this.state.country && feature.country) {
                        this.setCountryByCode(feature.country);
                    }
                    // Fill city input via selection path
                    const cityInput = this.$('#cityInput');
                    cityInput.value = feature.label;
                    this.state.place = feature;
                    this.state.source = 'gps';
                    TTLStore.add({...feature, source: 'gps'});
                    this.emitSelection();
                } catch (e) {
                    let msg = this.i18n.unavailable;
                    if (e.code === 1) msg = this.i18n.denied;
                    if (e.code === 3) msg = this.i18n.timeout;
                    this.error(msg);
                }
            });
        }

        /*********** Radius ***********/
        initRadius() {
            const range = this.$('#radiusRange');
            const out = this.$('#radiusOut');
            const sync = () => {
                out.textContent = range.value;
                this.state.radiusKm = Number(range.value);
                this.dispatch('location:radius-change', {radiusKm: this.state.radiusKm});
                this.emitSelection(false);
            };
            range.addEventListener('input', sync);
            sync();
        }

        /*********** Events ***********/
        emitSelection(includePlace = true) {
            if (!this.state.country) return; // need at least country
            if (includePlace && !this.state.place) return; // emit full selection only when place set
            const detail = {
                source: this.state.source,
                country: this.state.country,
                place: this.state.place || null,
                radiusKm: this.state.radiusKm,
            };
            this.dispatch('location:selected', detail);
        }

        dispatch(name, detail) {
            this.dispatchEvent(new CustomEvent(name, {detail, bubbles: true}));
        }

        error(err) {
            const msg = (typeof err === 'string') ? err : (err?.message || 'Unknown error');
            this.dispatch('location:error', {message: msg});
        }
    }

    customElements.define('location-selector', LocationSelector);

    /*****************
     * Demo Host Wiring
     *****************/
    const host = document.querySelector('location-selector');
    const debug = document.getElementById('debug');
    const log = (e) => {
        const time = new Date().toISOString().split('T')[1].replace('Z', '');
        debug.textContent = `${time}  ${e.type}: ` + JSON.stringify(e.detail, null, 2) + "\n\n" + debug.textContent;
    };
    ['location:selected', 'location:country-change', 'location:city-input', 'location:city-selected', 'location:use-gps', 'location:radius-change', 'location:error', 'location:reset-place']
        .forEach(ev => host.addEventListener(ev, log));
</script>
</body>
</html>
